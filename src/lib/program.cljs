(ns lib.program
  (:require
   [clojure.core.async :as a] ; Still required for take! return type
   [clojure.pprint :as pprint]))

;; --- Listener Management ---

(defn- unique-id [] (gensym "listener-"))

;; Listener map structure: {id {:fn f :msg-type type :once? bool}}
;; `id`: Unique symbol generated by unique-id
;; `:fn`: The function to call when a matching message arrives.
;; `:msg-type`: The message type keyword (or :*) to match.
;; `:once?`: Boolean, true if the listener should be removed after first invocation.

(defn- add-listener! [listeners-atom! msg-type listener-fn once?]
  (let [id (unique-id)]
    (swap! listeners-atom! assoc id {:fn listener-fn :msg-type msg-type :once? once?})
    id))

(defn msg-match?
  "Checks if a message vector matches a message type keyword."
  [msg msg-type]
  (or (= msg-type :*)
      (= (first msg) msg-type)))

;; --- Program Definition ---

(defn new
  "Creates a new program instance.
  A program manages state, reducers, effects, and message listeners."
  []
  (let [state! (atom {})
        eff-fns! (atom {})       ; Stores effect handlers: {eff-type eff-fn}
        reducer-fns! (atom {})   ; Stores reducer functions: {msg-type [reducer-fn ...]}
        listener-fns! (atom {})     ; Stores message listeners: {id listener-spec}
        program {:program/state! state!
                 :program/eff-fns! eff-fns!
                 :program/reducer-fns! reducer-fns!
                 :program/listener-fns! listener-fns!}]
    program))

;; --- State and Reducers ---

(defn- reduce-reducers [reducers state msg]
  (reduce
   (fn [current-state reducer-fn] (reducer-fn current-state msg))
   state
   reducers))

(defn- reducer
  "Applies registered reducers for a given message to the state."
  [program state [msg-type :as msg]]
  (let [{:keys [program/reducer-fns!]} program
        reducer-fns (get @reducer-fns! msg-type [])]
    (reduce-reducers reducer-fns state msg)))

(defn reg-reducer
  "Registers a reducer function for a specific message type.
  Reducer functions have the signature: (fn [state msg] new-state)."
  [program msg-type reducer-fn]
  #_(pprint/pprint {:reg-reducer msg-type})
  (let [{:keys [program/reducer-fns!]} program]
    (swap! reducer-fns! update msg-type (fnil conj []) reducer-fn))
  program) ; Return program for chaining

(defn state!
  "Returns the current state of the program."
  [program]
  (let [{:keys [program/state!]} program]
    @state!))

(defn- update-state! [{:keys [program/state!] :as program} msg]
  (swap! state! #(reducer program % msg)))

;; --- Effects ---

(defn eff!
  "Executes an effect handler registered for the effect message type.
  Effect messages are typically vectors like [:effect/type payload].
  Returns the result of the effect handler (often a channel or promise)."
  [program eff]
  #_(pprint/pprint {:eff eff})
  (let [{:keys [program/eff-fns!]} program
        eff-type (first eff)
        eff-fn! (get @eff-fns! eff-type)]
    (if eff-fn!
      (eff-fn! eff)
      (do (js/console.warn "No effect handler registered for type:" eff-type)
          nil))))

(defn reg-eff
  "Registers an effect handler function for a specific effect type.
  Effect handlers have the signature: (fn [eff-msg] result)."
  [program eff-type eff-fn]
  #_(pprint/pprint {:reg-eff eff-type})
  (let [{:keys [program/eff-fns!]} program]
    (swap! eff-fns! assoc eff-type eff-fn))
  program) ; Return program for chaining

;; --- Message Dispatch (put!) ---

(defn- msg->str [msg]
  (let [s (pr-str msg)]
    (if (> (count s) 1000)
      (str (first msg) " ... (truncated)")
      s)))

(defn put!
  "Updates the program state using registered reducers for the message type
  and notifies all matching listeners."
  [{:keys [program/listener-fns!] :as program} msg]
  (update-state! program msg)
  #_(pprint/pprint {:put! (msg->str msg)})

  ;; Notify listeners
  (let [current-listeners @listener-fns!
        listeners-to-remove (atom [])]
    (doseq [[id {:keys [fn msg-type once?]}] current-listeners]
      (when (msg-match? msg msg-type)
        (try
          (fn msg) ; Execute listener
          (catch js/Error e
            (js/console.error "Error in program listener:" id "for msg:" (msg->str msg) e)))
        (when once?
          (swap! listeners-to-remove conj id)))) ; Mark for removal if :once?

    ;; Remove listeners marked as :once? that were triggered
    (when (seq @listeners-to-remove)
      (swap! listener-fns! (fn [listeners] (apply dissoc listeners @listeners-to-remove)))))
  program)

;; --- Message Consumption (take!, take-every!) ---

(defn take!
  "Returns a core.async channel that will receive the *next* message
  matching the given msg-type. The listener is removed after the message is delivered."
  [{:keys [program/listener-fns!]} msg-type]
  #_(pprint/pprint {:take! msg-type})
  (let [ch (a/chan 1)] ; Output channel
    (add-listener! listener-fns! msg-type
                   (fn [msg]
                     ;; This function runs when put! finds a match.
                     ;; It puts the message onto the channel and closes it.
                     ;; The listener removal is handled by put! because :once? is true.
                     (a/put! ch msg)
                     (a/close! ch))
                   true) ; :once? is true
    ch)) ; Return the channel

(defn take-every!
  "Registers a persistent listener that calls the function `f` every time
  a message matching `msg-type` is put!.
  The function `f` receives the matching message as its argument.
  Returns nil (registers a side-effect)."
  [{:keys [program/listener-fns!]} msg-type f]
  #_(pprint/pprint {:take-every! msg-type})
  (add-listener! listener-fns! msg-type
                 (fn [msg]
                   ;; This function runs when put! finds a match.
                   ;; It simply calls the user-provided function f.
                   ;; The listener is not removed because :once? is false.
                   (try
                     (f msg)
                     (catch js/Error e
                       (js/console.error "Error in take-every! handler for msg:" (msg->str msg) e))))
                 false) ; :once? is false
  nil) ; Return nil as it's setting up a background listener
